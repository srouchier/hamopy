{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the hamopy documentation Hamopy is a python package for the numerical simulation of one-dimensional heat, air and moisture (HAM) transfer in porous materials. Its principle is the finite-element resolution of the HAM conservation equations. The only requirement to run it is a fairly recent version of SciPy. The original field of application is the hygrothermal modelling of building materials, although the code is not restricted to it. Hamopy makes good use of its open-source nature, and gives users complete control over the simulation process. One can: add new materials and customise the equations defining their properties, account for water flow and storage in both liquid and vapor states, include time-dependent boundary conditions, work with fully coupled hygrothermal transfer, or with thermal transfer only (saves time), easily automate many simulations for sensitivity analyses, evolutionary algorithms and such. Any contribution into improving hamopy is welcome, as to make open-source HAM modelling available and understandable by all. Installation hamopy may be installed by running pip install hamopy Alternatively, you can download and install hamopy by cloning the GitHub repository and running: python setup.py install How things work Once hamopy is detected by your Python installation, this is basically how a simulation is run: from hamopy.algorithm import calcul results = calcul(mesh, clim, init, time) The first line imports the main algorithm of hamopy, the second line runs the simulation under specified conditions (the mesh , clim , init and time objects) and stores results as a python dictionary. Of course, some questions remain unanswered, which is what this page is for. User guide Inputs : how to define the conditions of simulation Materials : how to create a new material Boundary conditions : how to set up boundary conditions Simulation : some options to customise and monitor the simulation Library : small library of useful functions within hamopy Post-processing : how to visualise results Examples Hamstad BM 3 : 3rd benchmark exercise of the Hamstad package Hamstad BM 5 : 5th benchmark exercise of the Hamstad package","title":"Home"},{"location":"#welcome-to-the-hamopy-documentation","text":"Hamopy is a python package for the numerical simulation of one-dimensional heat, air and moisture (HAM) transfer in porous materials. Its principle is the finite-element resolution of the HAM conservation equations. The only requirement to run it is a fairly recent version of SciPy. The original field of application is the hygrothermal modelling of building materials, although the code is not restricted to it. Hamopy makes good use of its open-source nature, and gives users complete control over the simulation process. One can: add new materials and customise the equations defining their properties, account for water flow and storage in both liquid and vapor states, include time-dependent boundary conditions, work with fully coupled hygrothermal transfer, or with thermal transfer only (saves time), easily automate many simulations for sensitivity analyses, evolutionary algorithms and such. Any contribution into improving hamopy is welcome, as to make open-source HAM modelling available and understandable by all.","title":"Welcome to the hamopy documentation"},{"location":"#installation","text":"hamopy may be installed by running pip install hamopy Alternatively, you can download and install hamopy by cloning the GitHub repository and running: python setup.py install","title":"Installation"},{"location":"#how-things-work","text":"Once hamopy is detected by your Python installation, this is basically how a simulation is run: from hamopy.algorithm import calcul results = calcul(mesh, clim, init, time) The first line imports the main algorithm of hamopy, the second line runs the simulation under specified conditions (the mesh , clim , init and time objects) and stores results as a python dictionary. Of course, some questions remain unanswered, which is what this page is for.","title":"How things work"},{"location":"#user-guide","text":"Inputs : how to define the conditions of simulation Materials : how to create a new material Boundary conditions : how to set up boundary conditions Simulation : some options to customise and monitor the simulation Library : small library of useful functions within hamopy Post-processing : how to visualise results","title":"User guide"},{"location":"#examples","text":"Hamstad BM 3 : 3rd benchmark exercise of the Hamstad package Hamstad BM 5 : 5th benchmark exercise of the Hamstad package","title":"Examples"},{"location":"about/author/","text":"Hamopy is maintained by Simon Rouchier, researcher at the Universit\u00e9 Savoie Mont-Blanc . The hamopy package is hosted on GitHub You can also check out my website here for other projects I am working on: https://simonrouchier.wordpress.com/","title":"Author"},{"location":"about/license/","text":"GNU LESSER GENERAL PUBLIC LICENSE Version 3, 29 June 2007 Copyright (C) 2007 Free Software Foundation, Inc. http://fsf.org/ Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed. This version of the GNU Lesser General Public License incorporates the terms and conditions of version 3 of the GNU General Public License, supplemented by the additional permissions listed below. Additional Definitions. As used herein, \"this License\" refers to version 3 of the GNU Lesser General Public License, and the \"GNU GPL\" refers to version 3 of the GNU General Public License. \"The Library\" refers to a covered work governed by this License, other than an Application or a Combined Work as defined below. An \"Application\" is any work that makes use of an interface provided by the Library, but which is not otherwise based on the Library. Defining a subclass of a class defined by the Library is deemed a mode of using an interface provided by the Library. A \"Combined Work\" is a work produced by combining or linking an Application with the Library. The particular version of the Library with which the Combined Work was made is also called the \"Linked Version\". The \"Minimal Corresponding Source\" for a Combined Work means the Corresponding Source for the Combined Work, excluding any source code for portions of the Combined Work that, considered in isolation, are based on the Application, and not on the Linked Version. The \"Corresponding Application Code\" for a Combined Work means the object code and/or source code for the Application, including any data and utility programs needed for reproducing the Combined Work from the Application, but excluding the System Libraries of the Combined Work. Exception to Section 3 of the GNU GPL. You may convey a covered work under sections 3 and 4 of this License without being bound by section 3 of the GNU GPL. Conveying Modified Versions. If you modify a copy of the Library, and, in your modifications, a facility refers to a function or data to be supplied by an Application that uses the facility (other than as an argument passed when the facility is invoked), then you may convey a copy of the modified version: a) under this License, provided that you make a good faith effort to ensure that, in the event an Application does not supply the function or data, the facility still operates, and performs whatever part of its purpose remains meaningful, or b) under the GNU GPL, with none of the additional permissions of this License applicable to that copy. Object Code Incorporating Material from Library Header Files. The object code form of an Application may incorporate material from a header file that is part of the Library. You may convey such object code under terms of your choice, provided that, if the incorporated material is not limited to numerical parameters, data structure layouts and accessors, or small macros, inline functions and templates (ten or fewer lines in length), you do both of the following: a) Give prominent notice with each copy of the object code that the Library is used in it and that the Library and its use are covered by this License. b) Accompany the object code with a copy of the GNU GPL and this license document. Combined Works. You may convey a Combined Work under terms of your choice that, taken together, effectively do not restrict modification of the portions of the Library contained in the Combined Work and reverse engineering for debugging such modifications, if you also do each of the following: a) Give prominent notice with each copy of the Combined Work that the Library is used in it and that the Library and its use are covered by this License. b) Accompany the Combined Work with a copy of the GNU GPL and this license document. c) For a Combined Work that displays copyright notices during execution, include the copyright notice for the Library among these notices, as well as a reference directing the user to the copies of the GNU GPL and this license document. d) Do one of the following: 0) Convey the Minimal Corresponding Source under the terms of this License, and the Corresponding Application Code in a form suitable for, and under terms that permit, the user to recombine or relink the Application with a modified version of the Linked Version to produce a modified Combined Work, in the manner specified by section 6 of the GNU GPL for conveying Corresponding Source. 1) Use a suitable shared library mechanism for linking with the Library. A suitable mechanism is one that (a) uses at run time a copy of the Library already present on the user's computer system, and (b) will operate properly with a modified version of the Library that is interface-compatible with the Linked Version. e) Provide Installation Information, but only if you would otherwise be required to provide such information under section 6 of the GNU GPL, and only to the extent that such information is necessary to install and execute a modified version of the Combined Work produced by recombining or relinking the Application with a modified version of the Linked Version. (If you use option 4d0, the Installation Information must accompany the Minimal Corresponding Source and Corresponding Application Code. If you use option 4d1, you must provide the Installation Information in the manner specified by section 6 of the GNU GPL for conveying Corresponding Source.) Combined Libraries. You may place library facilities that are a work based on the Library side by side in a single library together with other library facilities that are not Applications and are not covered by this License, and convey such a combined library under terms of your choice, if you do both of the following: a) Accompany the combined library with a copy of the same work based on the Library, uncombined with any other library facilities, conveyed under the terms of this License. b) Give prominent notice with the combined library that part of it is a work based on the Library, and explaining where to find the accompanying uncombined form of the same work. Revised Versions of the GNU Lesser General Public License. The Free Software Foundation may publish revised and/or new versions of the GNU Lesser General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. Each version is given a distinguishing version number. If the Library as you received it specifies that a certain numbered version of the GNU Lesser General Public License \"or any later version\" applies to it, you have the option of following the terms and conditions either of that published version or of any later version published by the Free Software Foundation. If the Library as you received it does not specify a version number of the GNU Lesser General Public License, you may choose any version of the GNU Lesser General Public License ever published by the Free Software Foundation. If the Library as you received it specifies that a proxy can decide whether future versions of the GNU Lesser General Public License shall apply, that proxy's public statement of acceptance of any version is permanent authorization for you to choose that version for the Library.","title":"License"},{"location":"examples/Hamstad_BM3/","text":"Hamstad BM3 This script simulates the third exercise of the Hamstad benchmark package: transient heat and moisture transfer impacted by air flow through a lightweight wall. Note that the external air pressure fluctuates on one side of the domain, and that its values are read from a .txt file which has two columns labeled Time (s) and DeltaP . This file is available in the hamopy/benchmarks folder Script import numpy as np import pandas as pd import matplotlib.pylab as plt # All things necessary to run the simulation from hamopy import ham_library as ham from hamopy.classes import Mesh, Boundary, Time from hamopy.algorithm import calcul from hamopy.postpro import evolution # Choice of materials and geometry from hamopy.materials.hamstad import BM3 mesh = Mesh(**{\"materials\" : [BM3], \"sizes\" : [0.2], \"nbr_elements\" : [40] }) # Boundary conditions clim_file = 'BM3 climate.txt' clim1 = Boundary('Fourier',**{\"file\" : clim_file, \"time\" : \"Time (s)\", \"T\" : 293.15, \"HR\" : 0.7, \"h_t\" : 10, \"h_m\" : 2e-7, \"P_air\" : \"DeltaP\"}) clim2 = Boundary('Fourier',**{\"T\" : 275.15, \"HR\" : 0.8, \"h_t\" : 10, \"h_m\" : 7.38e-12 }) clim = [clim1, clim2] # Initial conditions init = {'T' : 293.15, 'HR' : 0.95} # Time step control time = Time('variable',**{\"delta_t\" : 900, \"t_max\" : 8640000, \"iter_max\" : 12, \"delta_min\": 1e-3, \"delta_max\": 900 } ) # Calculation results = calcul(mesh, clim, init, time) # Post processing: what time and coordinate scales we wish to display the results on data0 = pd.read_csv(clim_file, delimiter='\\t') t_out = np.array( data0['Time (s)'] ) x_out = [0.05, 0.1, 0.15, 0.17, 0.19] # Use the evolution function to extract the temperature and humidity profiles Temperature = np.column_stack([evolution(results, 'T', _, t_out) for _ in x_out]) Humidity = np.column_stack([evolution(results, 'HR', _, t_out) for _ in x_out]) MoistureContent = BM3.w(ham.p_c(Humidity, Temperature), Temperature) # Plotting results fig, ax = plt.subplots(2, 1) ax[0].plot(t_out / (24 * 3600), Temperature) ax[0].set_xlabel('Time (days)') ax[0].set_ylabel('Temperature (C)') ax[0].legend(('x=0.05 m', 'x=0.1 m', 'x=0.15 m', 'x=0.17 m', 'x=0.19 m')) ax[1].plot(t_out / (24 * 3600), MoistureContent) ax[1].set_xlabel('Time (days)') ax[1].set_ylabel('Moisture content (kg/m3)') ax[1].legend(('x=0.05 m', 'x=0.1 m', 'x=0.15 m', 'x=0.17 m', 'x=0.19 m')) plt.show() Results","title":"Hamstad BM3"},{"location":"examples/Hamstad_BM3/#hamstad-bm3","text":"This script simulates the third exercise of the Hamstad benchmark package: transient heat and moisture transfer impacted by air flow through a lightweight wall. Note that the external air pressure fluctuates on one side of the domain, and that its values are read from a .txt file which has two columns labeled Time (s) and DeltaP . This file is available in the hamopy/benchmarks folder","title":"Hamstad BM3"},{"location":"examples/Hamstad_BM3/#script","text":"import numpy as np import pandas as pd import matplotlib.pylab as plt # All things necessary to run the simulation from hamopy import ham_library as ham from hamopy.classes import Mesh, Boundary, Time from hamopy.algorithm import calcul from hamopy.postpro import evolution # Choice of materials and geometry from hamopy.materials.hamstad import BM3 mesh = Mesh(**{\"materials\" : [BM3], \"sizes\" : [0.2], \"nbr_elements\" : [40] }) # Boundary conditions clim_file = 'BM3 climate.txt' clim1 = Boundary('Fourier',**{\"file\" : clim_file, \"time\" : \"Time (s)\", \"T\" : 293.15, \"HR\" : 0.7, \"h_t\" : 10, \"h_m\" : 2e-7, \"P_air\" : \"DeltaP\"}) clim2 = Boundary('Fourier',**{\"T\" : 275.15, \"HR\" : 0.8, \"h_t\" : 10, \"h_m\" : 7.38e-12 }) clim = [clim1, clim2] # Initial conditions init = {'T' : 293.15, 'HR' : 0.95} # Time step control time = Time('variable',**{\"delta_t\" : 900, \"t_max\" : 8640000, \"iter_max\" : 12, \"delta_min\": 1e-3, \"delta_max\": 900 } ) # Calculation results = calcul(mesh, clim, init, time) # Post processing: what time and coordinate scales we wish to display the results on data0 = pd.read_csv(clim_file, delimiter='\\t') t_out = np.array( data0['Time (s)'] ) x_out = [0.05, 0.1, 0.15, 0.17, 0.19] # Use the evolution function to extract the temperature and humidity profiles Temperature = np.column_stack([evolution(results, 'T', _, t_out) for _ in x_out]) Humidity = np.column_stack([evolution(results, 'HR', _, t_out) for _ in x_out]) MoistureContent = BM3.w(ham.p_c(Humidity, Temperature), Temperature) # Plotting results fig, ax = plt.subplots(2, 1) ax[0].plot(t_out / (24 * 3600), Temperature) ax[0].set_xlabel('Time (days)') ax[0].set_ylabel('Temperature (C)') ax[0].legend(('x=0.05 m', 'x=0.1 m', 'x=0.15 m', 'x=0.17 m', 'x=0.19 m')) ax[1].plot(t_out / (24 * 3600), MoistureContent) ax[1].set_xlabel('Time (days)') ax[1].set_ylabel('Moisture content (kg/m3)') ax[1].legend(('x=0.05 m', 'x=0.1 m', 'x=0.15 m', 'x=0.17 m', 'x=0.19 m')) plt.show()","title":"Script"},{"location":"examples/Hamstad_BM3/#results","text":"","title":"Results"},{"location":"examples/Hamstad_BM5/","text":"Hamstad BM5 This script simulates the fifth exercise of the Hamstad benchmark package: multi-layered wall with capillary active inside insulation Since hamopy is not really speed-optimised, this may take a few minutes to compute. Script \"\"\" 5th exercise of the Hamstad benchmark package Capillary active inside insulation \"\"\" import numpy as np import matplotlib.pylab as plt # All things necessary to run the simulation from hamopy import ham_library as ham from hamopy.classes import Mesh, Boundary, Time from hamopy.algorithm import calcul from hamopy.postpro import distribution # Choice of materials and geometry from hamopy.materials.hamstad import BM5_brick, BM5_mortar, BM5_insulation mesh = Mesh(**{\"materials\" : [BM5_brick, BM5_mortar, BM5_insulation], \"sizes\" : [0.365, 0.015, 0.040], \"nbr_elements\" : [100, 20, 20] }) # Boundary conditions clim1 = Boundary('Fourier',**{\"T\" : 273.15, \"HR\" : 0.8, \"h_t\" : 25., \"h_m\" : 1.8382e-7 }) clim2 = Boundary('Fourier',**{\"T\" : 293.15, \"HR\" : 0.6, \"h_t\" : 8., \"h_m\" : 5.8823e-8 }) clim = [clim1, clim2] # Initial conditions init = {'T' : 298.15, 'HR' : 0.6} # Time step size time = Time('variable',**{\"delta_t\" : 900, \"t_max\" : 12960000, \"iter_max\" : 12, \"delta_min\": 1e-3, \"delta_max\": 900 } ) # Calculation result = calcul(mesh, clim, init, time) # Post processing t_plot = 12960000 x_plot = np.linspace(0, 0.42, 421) Temperature = distribution(result, 'T', x_plot, t_plot) Humidity = distribution(result, 'HR', x_plot, t_plot) Moisture = np.zeros(np.shape(Temperature)) for i in range(len(mesh.materials)): xmin = sum(mesh.sizes[0:i]) xmax = sum(mesh.sizes[0:i+1]) mask = ((x_plot >= xmin) & (x_plot <= xmax)) Moisture[mask] = mesh.materials[i].w(ham.p_c(Humidity[mask],Temperature[mask]), Temperature[mask]) # Plotting results fig, ax = plt.subplots(2, 1) ax[0].plot(x_plot[300:], Humidity[300:], 'k-', linewidth=2) ax[0].set_xlabel('x (m)') ax[0].set_ylabel('Relative humidity') ax[1].plot(x_plot[300:], Moisture[300:], 'k-', linewidth=2) ax[1].set_xlabel('x (m)') ax[1].set_ylabel('Moisture content (kg/m3)') plt.show() Results","title":"Hamstad BM5"},{"location":"examples/Hamstad_BM5/#hamstad-bm5","text":"This script simulates the fifth exercise of the Hamstad benchmark package: multi-layered wall with capillary active inside insulation Since hamopy is not really speed-optimised, this may take a few minutes to compute.","title":"Hamstad BM5"},{"location":"examples/Hamstad_BM5/#script","text":"\"\"\" 5th exercise of the Hamstad benchmark package Capillary active inside insulation \"\"\" import numpy as np import matplotlib.pylab as plt # All things necessary to run the simulation from hamopy import ham_library as ham from hamopy.classes import Mesh, Boundary, Time from hamopy.algorithm import calcul from hamopy.postpro import distribution # Choice of materials and geometry from hamopy.materials.hamstad import BM5_brick, BM5_mortar, BM5_insulation mesh = Mesh(**{\"materials\" : [BM5_brick, BM5_mortar, BM5_insulation], \"sizes\" : [0.365, 0.015, 0.040], \"nbr_elements\" : [100, 20, 20] }) # Boundary conditions clim1 = Boundary('Fourier',**{\"T\" : 273.15, \"HR\" : 0.8, \"h_t\" : 25., \"h_m\" : 1.8382e-7 }) clim2 = Boundary('Fourier',**{\"T\" : 293.15, \"HR\" : 0.6, \"h_t\" : 8., \"h_m\" : 5.8823e-8 }) clim = [clim1, clim2] # Initial conditions init = {'T' : 298.15, 'HR' : 0.6} # Time step size time = Time('variable',**{\"delta_t\" : 900, \"t_max\" : 12960000, \"iter_max\" : 12, \"delta_min\": 1e-3, \"delta_max\": 900 } ) # Calculation result = calcul(mesh, clim, init, time) # Post processing t_plot = 12960000 x_plot = np.linspace(0, 0.42, 421) Temperature = distribution(result, 'T', x_plot, t_plot) Humidity = distribution(result, 'HR', x_plot, t_plot) Moisture = np.zeros(np.shape(Temperature)) for i in range(len(mesh.materials)): xmin = sum(mesh.sizes[0:i]) xmax = sum(mesh.sizes[0:i+1]) mask = ((x_plot >= xmin) & (x_plot <= xmax)) Moisture[mask] = mesh.materials[i].w(ham.p_c(Humidity[mask],Temperature[mask]), Temperature[mask]) # Plotting results fig, ax = plt.subplots(2, 1) ax[0].plot(x_plot[300:], Humidity[300:], 'k-', linewidth=2) ax[0].set_xlabel('x (m)') ax[0].set_ylabel('Relative humidity') ax[1].plot(x_plot[300:], Moisture[300:], 'k-', linewidth=2) ax[1].set_xlabel('x (m)') ax[1].set_ylabel('Moisture content (kg/m3)') plt.show()","title":"Script"},{"location":"examples/Hamstad_BM5/#results","text":"","title":"Results"},{"location":"user-guide/boundary/","text":"Boundary conditions Constant conditions The clim argument sent to the simulation is a list of two objects of the Boundary class. The instantiation of a boundary requires two arguments: a string to specify the boundary type, and a dictionary to specify numerical data. The input definition page shows a simple example of how boundary conditions can be defined: from hamopy.classes import Boundary clim_01 = Boundary('Dirichlet',**{\"T\" : 293.15, \"HR\" : 0.7 }) clim_02 = Boundary('Fourier',**{\"T\" : 278.15, \"HR\" : 0.9, \"h_t\" : 5 }) clim = [clim_01, clim_02] Two boundaries are created separately and stored in the clim list. The first one is a constant type one (Dirichlet) condition of 293.15 K and 0.7 relative humidity. The second one is a type three (Fourier) conditions with a surface transfer coefficient of 5 [W/(m2K)]. Variable conditions The example above is very simple, but things can get a little more complicated: boundary conditions can be variable in time and more parameters can be specified (air pressure, surface transfer coefficients...) Let's say one of your boundaries has a variable temperature and air pressure, which are stored in a .txt file with headers . In this case, this is how you instantiate a new boundary with the second column as the temperature and the third column as the air pressure: clim_file = 'path_to_your_file/file_name.txt' clim_01 = Boundary('Fourier',**{\"file\" : clim_file, \"time\" : \"Time (s)\", \"T\" : \"Temp. (K)\", \"P_air\" : \"Air pressure\", \"HR\" : 0.7, \"h_t\" : 10, \"h_m\" : 2e-7 }) where \"Time (s)\", \"Temp. (K)\" and \"Air pressure\" are headers of the text file, on top of each variable of interest. A boundary can be assigned both constant and variable values at the same time: If a key of the dictionary points to a string (like 'T' and 'P_air' above), then Boundary will attempt to read it under the corresponding header in the .txt file. If a key points to a numerical value (like 'HR' , 'h_t' and 'h_m' above), Boundary will keep it constant during the entire simulation time. If any boundary value varies, the dictionary must contain a 'file' key pointing to the file location on your drive, and a 'time' key pointing to the column containing time coordinates. Note that you can use a single file to store data for both of your domain boundaries, like so: clim_file = 'path_to_your_file/file_name.txt' clim_01 = Boundary('Fourier',**{\"file\" : clim_file, \"time\" : \"Time (s)\", \"T\" : \"Temp. (K)\", \"P_air\" : \"Air pressure\", \"HR\" : 0.7, \"h_t\" : 10, \"h_m\" : 2e-7 }) clim_02 = Boundary('Dirichlet',**{\"file\" : clim_file, \"time\" : \"Time (s)\", \"T\" : \"Temp. 2 (K)\", \"HR\" : 0.85 }) clim = [clim_01, clim_02] This formulation aims at giving maximum flexibility for the definition of the boundary conditions. Keys The dictionary which you give as argument for the instantiation of a new 'Boundary' object may specify more content than in the examples above. The following is a list of the keys that may (or should) be included in it. 'T' : temperature in \u00b0C or K 'HR' : relative humidity (dimensionless) 'p_v' : water vapor pressure (Pa), only needed if HR is not given 'h_t' : surface heat transfer coefficient (W/(m2.K)). Optional, default value is 5 W/(m2.K) 'h_m' : surface moisture transfer coefficient (s/m). Optional, default is 7.45e-9 * h_t 'T_eq' : equivalent temperature, accounting for effects of solar radiation. Optional, it is set equal to 'T' if not given. 'g_l' : liquid water income caused by rain (kg/(m2.s)). Optional, default value is zero 'P_air' : air pressure (Pa), impacting eventual air transfer in the wall. Optional, default value is zero Any of these values can either be constant, or read from a .txt file. In this case, these additional keys should be given in the dictionary: 'file' : file location on the hard drive 'delimiter' : delimiter used in the text file. Default is tab. 'time' : location of the time data in the text file Documentation main page","title":"Boundary conditions"},{"location":"user-guide/boundary/#boundary-conditions","text":"","title":"Boundary conditions"},{"location":"user-guide/boundary/#constant-conditions","text":"The clim argument sent to the simulation is a list of two objects of the Boundary class. The instantiation of a boundary requires two arguments: a string to specify the boundary type, and a dictionary to specify numerical data. The input definition page shows a simple example of how boundary conditions can be defined: from hamopy.classes import Boundary clim_01 = Boundary('Dirichlet',**{\"T\" : 293.15, \"HR\" : 0.7 }) clim_02 = Boundary('Fourier',**{\"T\" : 278.15, \"HR\" : 0.9, \"h_t\" : 5 }) clim = [clim_01, clim_02] Two boundaries are created separately and stored in the clim list. The first one is a constant type one (Dirichlet) condition of 293.15 K and 0.7 relative humidity. The second one is a type three (Fourier) conditions with a surface transfer coefficient of 5 [W/(m2K)].","title":"Constant conditions"},{"location":"user-guide/boundary/#variable-conditions","text":"The example above is very simple, but things can get a little more complicated: boundary conditions can be variable in time and more parameters can be specified (air pressure, surface transfer coefficients...) Let's say one of your boundaries has a variable temperature and air pressure, which are stored in a .txt file with headers . In this case, this is how you instantiate a new boundary with the second column as the temperature and the third column as the air pressure: clim_file = 'path_to_your_file/file_name.txt' clim_01 = Boundary('Fourier',**{\"file\" : clim_file, \"time\" : \"Time (s)\", \"T\" : \"Temp. (K)\", \"P_air\" : \"Air pressure\", \"HR\" : 0.7, \"h_t\" : 10, \"h_m\" : 2e-7 }) where \"Time (s)\", \"Temp. (K)\" and \"Air pressure\" are headers of the text file, on top of each variable of interest. A boundary can be assigned both constant and variable values at the same time: If a key of the dictionary points to a string (like 'T' and 'P_air' above), then Boundary will attempt to read it under the corresponding header in the .txt file. If a key points to a numerical value (like 'HR' , 'h_t' and 'h_m' above), Boundary will keep it constant during the entire simulation time. If any boundary value varies, the dictionary must contain a 'file' key pointing to the file location on your drive, and a 'time' key pointing to the column containing time coordinates. Note that you can use a single file to store data for both of your domain boundaries, like so: clim_file = 'path_to_your_file/file_name.txt' clim_01 = Boundary('Fourier',**{\"file\" : clim_file, \"time\" : \"Time (s)\", \"T\" : \"Temp. (K)\", \"P_air\" : \"Air pressure\", \"HR\" : 0.7, \"h_t\" : 10, \"h_m\" : 2e-7 }) clim_02 = Boundary('Dirichlet',**{\"file\" : clim_file, \"time\" : \"Time (s)\", \"T\" : \"Temp. 2 (K)\", \"HR\" : 0.85 }) clim = [clim_01, clim_02] This formulation aims at giving maximum flexibility for the definition of the boundary conditions.","title":"Variable conditions"},{"location":"user-guide/boundary/#keys","text":"The dictionary which you give as argument for the instantiation of a new 'Boundary' object may specify more content than in the examples above. The following is a list of the keys that may (or should) be included in it. 'T' : temperature in \u00b0C or K 'HR' : relative humidity (dimensionless) 'p_v' : water vapor pressure (Pa), only needed if HR is not given 'h_t' : surface heat transfer coefficient (W/(m2.K)). Optional, default value is 5 W/(m2.K) 'h_m' : surface moisture transfer coefficient (s/m). Optional, default is 7.45e-9 * h_t 'T_eq' : equivalent temperature, accounting for effects of solar radiation. Optional, it is set equal to 'T' if not given. 'g_l' : liquid water income caused by rain (kg/(m2.s)). Optional, default value is zero 'P_air' : air pressure (Pa), impacting eventual air transfer in the wall. Optional, default value is zero Any of these values can either be constant, or read from a .txt file. In this case, these additional keys should be given in the dictionary: 'file' : file location on the hard drive 'delimiter' : delimiter used in the text file. Default is tab. 'time' : location of the time data in the text file Documentation main page","title":"Keys"},{"location":"user-guide/example/","text":"This scipt simulates the third exercise of the Hamstad benchmark package: transient heat and moisture transfer impacted by air flow through a lightweight wall. Note that the external air pressure fluctuates on one side of the domain, and that its values are read from a .txt file which has two columns labeled Time (s) and DeltaP . This file is available in the hamopy/benchmarks folder from hamopy.classes import Mesh, Boundary, Time # Meshing from hamopy.materials.hamstad import BM3 mesh = Mesh(**{\"materials\" : [BM3], \"sizes\" : [0.2], \"nbr_elements\" : [40] }) # Boundary conditions clim_file = 'BM3 climate.txt' clim1 = Boundary('Fourier',**{\"file\" : clim_file, \"time\" : \"Time (s)\", \"T\" : 293.15, \"HR\" : 0.7, \"h_t\" : 10, \"h_m\" : 2e-7, \"P_air\" : \"DeltaP\"}) clim2 = Boundary('Fourier',**{\"T\" : 275.15, \"HR\" : 0.8, \"h_t\" : 10, \"h_m\" : 7.38e-12 }) clim = [clim1, clim2] # Initial conditions init = {'T' : 293.15, 'HR' : 0.95} # Temporal discretisation time = Time('variable',**{\"delta_t\" : 900, \"t_max\" : 8640000, \"iter_max\" : 12, \"delta_min\": 1e-3, \"delta_max\": 900 } ) if __name__ == \"__main__\": import numpy as np import pandas as pd # Simulation from hamopy.algorithm import calcul results = calcul(mesh, clim, init, time) # Post-processing from hamopy.postpro import evolution data0 = pd.read_csv(clim_file, delimiter='\\t') t_out = np.array( data0['Time (s)'] ) x_out = [0.05, 0.1, 0.15, 0.17, 0.19] from hamopy import ham_library as ham Temperature = np.column_stack([evolution(results, 'T', _, t_out) for _ in x_out]) Humidity = np.column_stack([evolution(results, 'HR', _, t_out) for _ in x_out]) MoistureContent = BM3.w(ham.p_c(Humidity, Temperature), Temperature) # Plotting results import matplotlib.pylab as plt from matplotlib import rc rc(\"font\", family=\"serif\", size=12) figsize(6, 8) ax = plt.subplot(211) plt.plot(t_plot / (24*3600), Temperature) plt.xlabel('Time (days)') plt.ylabel('Temperature (C)') plt.legend(('x=0.05 m', 'x=0.1 m', 'x=0.15 m', 'x=0.17 m', 'x=0.19 m')) ax = plt.subplot(212) plt.plot(t_plot / (24*3600), MoistCont) plt.xlabel('Time (days)') plt.ylabel('Moisture content (kg/m3)') plt.legend(('x=0.05 m', 'x=0.1 m', 'x=0.15 m', 'x=0.17 m', 'x=0.19 m')) fig = plt.gcf() fig.savefig('BM3_results.png', format='png', dpi = 300)","title":"Example"},{"location":"user-guide/inputs/","text":"Input definition The hamopy algorithm is called like so: from hamopy.algorithm import calcul results = calcul(mesh, clim, init, time) This means that all inputs of the simulation are contained within 4 objects that serve as arguments for the calcul method: mesh contains all information regarding the material definition and spatial discretisation of the domain clim stores boundary conditions init defines the initialisation of the domain time specifies the time of simulation, time step size, etc. Below is the syntax for the definition of these objects. mesh: material definition and discretisation The mesh argument is created by instantiating a new object of the hamopy.classes.Mesh class. from hamopy.classes import Mesh from hamopy.materials.standard import wood_fibre mesh = Mesh(materials = [wood_fibre], sizes = [0.08], nbr_elements = [16] ) The example above imports the wood fibre board from the hamopy.materials.standard material library. Then, it creates a wall of thickness 0.08 m, discretised with 16 finite elements. Here is an example of a multi-layered wall: from hamopy.classes import Mesh from hamopy.materials.standard import concrete, wood_fibre mesh = Mesh(materials = [concrete, wood_fibre], sizes = [0.10, 0.08], nbr_elements = [24, 16] ) From left to right, this example creates a wall with a 10 cm concrete layer divided into 24 finite elements, and an 8 cm wood fibre layer with 16 finite elements. The instantiation of the Mesh class always takes 3 arguments: materials , sizes and nbr_elements . These arguments are always lists , even when only one layer is involved as in the first example. Materials must be imported before the mesh is created. They are objects of the Material class: the materials page of this site shows how to define one. clim: boundary conditions The clim argument sent to the simulation is a list of two objects of the Boundary class. from hamopy.classes import Boundary clim_01 = Boundary('Dirichlet',**{\"T\" : 293.15, \"HR\" : 0.7 }) clim_02 = Boundary('Fourier',**{\"T\" : 278.15, \"HR\" : 0.9, \"h_t\" : 5 }) clim = [clim_01, clim_02] Two boundaries are created separately and stored in the clim list. The first one is a constant type one (Dirichlet) condition of 293.15 K and 0.7 relative humidity. The second one is a type three (Fourier) conditions with a surface transfer coefficient of 5 [W/(m2K)]. The instantiation of a boundary requires two arguments: a string to specify the boundary type, and a dictionary to specify numerical data. The example above is very simple, but things can get a little more complicated: boundary conditions can be variable in time and more parameters can be specified (air pressure, surface transfer coefficients...) The boundary conditions page shows how to do all that. init: initialisation The init object is simply a dictionary containing the initial value of the temperature under the 'T' key, and of the relative humidity under the 'HR' key: init = {'T' : 293.15, 'HR' : 0.95} Alternatively, the relative humidity can be replaced by a value of vapor pressure with the 'PV' key or of capillary pressure with the 'PC' key. It is possible to define non-uniform initial conditions, by adding an 'x' key to the dictionary: init = {'x' : [0, 0.05, 0.10], 'T' : [273, 287, 291], 'HR' : [0.7, 0.4, 0.6] } In this example, the initial conditions will be a linear interpolation of the values given at the coordinates 0, 0.05, and 0.10 m. time: temporal discretisation The object storing information on the discretisation in time is an occurence of the Time class. Its instantiation resembles that of the Boundary object: from hamopy.classes import Time time = Time('constant',**{\"delta_t\" : 600, \"t_max\" : 7200 } ) The definition of the time requires two input arguments: a string indicating whether the time step size should be constant or variable, and a dictionary containing numerical data. In the example above, it is declared that the time step size delta_t is 600 seconds, and that the simulation time t_max is 7200 seconds. It is possible to ask for the time step size to automatically adapt to eventual convergence difficulties. This is done by setting the method string to 'variable' , and optionnaly adding some keys to the dictionary: 'iter_max' : maximum number of iterations in a time step (default is 12) 'delta_min' : minimum time step size (default is 1e-3) 'delta_max' : maximum time step size (default is 900) Once all 4 objects are defined, you can start the simulation . Documentation main page","title":"Input definition"},{"location":"user-guide/inputs/#input-definition","text":"The hamopy algorithm is called like so: from hamopy.algorithm import calcul results = calcul(mesh, clim, init, time) This means that all inputs of the simulation are contained within 4 objects that serve as arguments for the calcul method: mesh contains all information regarding the material definition and spatial discretisation of the domain clim stores boundary conditions init defines the initialisation of the domain time specifies the time of simulation, time step size, etc. Below is the syntax for the definition of these objects.","title":"Input definition"},{"location":"user-guide/inputs/#mesh-material-definition-and-discretisation","text":"The mesh argument is created by instantiating a new object of the hamopy.classes.Mesh class. from hamopy.classes import Mesh from hamopy.materials.standard import wood_fibre mesh = Mesh(materials = [wood_fibre], sizes = [0.08], nbr_elements = [16] ) The example above imports the wood fibre board from the hamopy.materials.standard material library. Then, it creates a wall of thickness 0.08 m, discretised with 16 finite elements. Here is an example of a multi-layered wall: from hamopy.classes import Mesh from hamopy.materials.standard import concrete, wood_fibre mesh = Mesh(materials = [concrete, wood_fibre], sizes = [0.10, 0.08], nbr_elements = [24, 16] ) From left to right, this example creates a wall with a 10 cm concrete layer divided into 24 finite elements, and an 8 cm wood fibre layer with 16 finite elements. The instantiation of the Mesh class always takes 3 arguments: materials , sizes and nbr_elements . These arguments are always lists , even when only one layer is involved as in the first example. Materials must be imported before the mesh is created. They are objects of the Material class: the materials page of this site shows how to define one.","title":"mesh: material definition and discretisation"},{"location":"user-guide/inputs/#clim-boundary-conditions","text":"The clim argument sent to the simulation is a list of two objects of the Boundary class. from hamopy.classes import Boundary clim_01 = Boundary('Dirichlet',**{\"T\" : 293.15, \"HR\" : 0.7 }) clim_02 = Boundary('Fourier',**{\"T\" : 278.15, \"HR\" : 0.9, \"h_t\" : 5 }) clim = [clim_01, clim_02] Two boundaries are created separately and stored in the clim list. The first one is a constant type one (Dirichlet) condition of 293.15 K and 0.7 relative humidity. The second one is a type three (Fourier) conditions with a surface transfer coefficient of 5 [W/(m2K)]. The instantiation of a boundary requires two arguments: a string to specify the boundary type, and a dictionary to specify numerical data. The example above is very simple, but things can get a little more complicated: boundary conditions can be variable in time and more parameters can be specified (air pressure, surface transfer coefficients...) The boundary conditions page shows how to do all that.","title":"clim: boundary conditions"},{"location":"user-guide/inputs/#init-initialisation","text":"The init object is simply a dictionary containing the initial value of the temperature under the 'T' key, and of the relative humidity under the 'HR' key: init = {'T' : 293.15, 'HR' : 0.95} Alternatively, the relative humidity can be replaced by a value of vapor pressure with the 'PV' key or of capillary pressure with the 'PC' key. It is possible to define non-uniform initial conditions, by adding an 'x' key to the dictionary: init = {'x' : [0, 0.05, 0.10], 'T' : [273, 287, 291], 'HR' : [0.7, 0.4, 0.6] } In this example, the initial conditions will be a linear interpolation of the values given at the coordinates 0, 0.05, and 0.10 m.","title":"init: initialisation"},{"location":"user-guide/inputs/#time-temporal-discretisation","text":"The object storing information on the discretisation in time is an occurence of the Time class. Its instantiation resembles that of the Boundary object: from hamopy.classes import Time time = Time('constant',**{\"delta_t\" : 600, \"t_max\" : 7200 } ) The definition of the time requires two input arguments: a string indicating whether the time step size should be constant or variable, and a dictionary containing numerical data. In the example above, it is declared that the time step size delta_t is 600 seconds, and that the simulation time t_max is 7200 seconds. It is possible to ask for the time step size to automatically adapt to eventual convergence difficulties. This is done by setting the method string to 'variable' , and optionnaly adding some keys to the dictionary: 'iter_max' : maximum number of iterations in a time step (default is 12) 'delta_min' : minimum time step size (default is 1e-3) 'delta_max' : maximum time step size (default is 900) Once all 4 objects are defined, you can start the simulation . Documentation main page","title":"time: temporal discretisation"},{"location":"user-guide/library/","text":"Library of functions All material-independant values, universal constants and state equations are stored within the hamopy/ham_library file. In addition to constant properties such as the latent heat of evaporation, the universal gas constant and the thermal conductivity of air, the file includes 5 useful methods: p_sat(T) : Water vapor saturation pressure (Pa) D_va(T) : Water vapor diffusivity in air (m2/s) p_v(p_c, T) : Water vapor pressure (Pa) HR(p_c, T) : Relative humidity p_c(HR, T) : Capillary pressure (Pa) The last three methods are equivalent formulations of the Clausius-Clapeyron equation. It is used to calculate the relative humidity from values of the capillary pressure, and inversely. Here is an example of use: from hamopy import ham_library as ham ham.cp_liq ham.p_sat(280) ham.p_c(0.92, 299) This script first returns the value of the liquid water specific heat, then the water vapor saturation pressure at 280 K, then the capillary pressure at 92 %RH and 299 K. Documentation main page","title":"Library"},{"location":"user-guide/library/#library-of-functions","text":"All material-independant values, universal constants and state equations are stored within the hamopy/ham_library file. In addition to constant properties such as the latent heat of evaporation, the universal gas constant and the thermal conductivity of air, the file includes 5 useful methods: p_sat(T) : Water vapor saturation pressure (Pa) D_va(T) : Water vapor diffusivity in air (m2/s) p_v(p_c, T) : Water vapor pressure (Pa) HR(p_c, T) : Relative humidity p_c(HR, T) : Capillary pressure (Pa) The last three methods are equivalent formulations of the Clausius-Clapeyron equation. It is used to calculate the relative humidity from values of the capillary pressure, and inversely. Here is an example of use: from hamopy import ham_library as ham ham.cp_liq ham.p_sat(280) ham.p_c(0.92, 299) This script first returns the value of the liquid water specific heat, then the water vapor saturation pressure at 280 K, then the capillary pressure at 92 %RH and 299 K. Documentation main page","title":"Library of functions"},{"location":"user-guide/materials/","text":"Creating materials As shown on the input definition page, creating the mesh object for the simulation requires including a material object in the arguments of the Mesh instantiation. from hamopy.classes import Mesh from hamopy.materials.standard import wood_fibre mesh = Mesh(materials = [wood_fibre], sizes = [0.08], nbr_elem = [16] ) This means that the hamopy\\materials\\standard.py file contains the definition of an object called wood_fibre , which is of the Material class and includes all material data. Material definition in hamopy is a bit tricky, as it was designed to give the user maximum freedom for defining fully customisable transport properties. This page tells you how to define a new material, use its properties once they have been registered, modify a material in an existing mesh. Material definition Instantiation For purposes of reusability, the definition of a new material should preferably be done in a separate file which you can then import into your script (like hamopy.materials.standard above) Once there, you may start by instantiating a new Material object: from hamopy.classes import Material concrete = Material('concrete', rho = 2400., cp = 880.) The instantiation may take up to three arguments: the material name, its dry density (kg/m3) and specific heat (J/(kg.K)). Once created, the Material object contains the following set of methods to register all material properties. set_density() If not provided at the instantiation, you can specify the dry density of the material like so: concrete.set_density(2430.) set_capacity() In the current state of hamopy, the heat capacity (J/(kg.K)) of the dry material can be defined as a function of the temperature. concrete.set_capacity(cp_0 = 2430., cp_t = 27.) When called, the value of the heat capacity will then be cp = cp_0 + T(\u00b0C) * cp_t The default value for cp_t is 0. set_conduc() The thermal conductivity (W/(m.K)) may be defined as a function of the moisture content and temperature. concrete.set_conduc(lambda_0 = 1.75, lambda_m = 4.5, lambda_t = 1e-4) When called, the value of the conductivity will then be lambda = lambda_0 + w(kg/m3)/1000 * lambda_m + T(\u00b0C) * lambda_t The default value for lambda_m and lambda_t is 0. set_isotherm() There are currently two methods for defining the sorption isotherm: Either a 3rd degree polynomial interpolation, fitted on a list of measurement points: wood_fibre.set_isotherm('polynomial', **{\"HR\" : [0, 0.25, 0.5, 0.75], \"W\" : [0, 6.2, 12.4, 20.9] }) where the list given in the 'W' key are the values of the moisture content measured at the relative humidities 'HR' . The second method for defining the sorption isotherm is the van Genuchten mono- or multimodal law: lightweight.set_isotherm('vangenuchten', **{\"w_sat\" : 871, \"l\" : [0.41, 0.59], \"alpha\" : [6.12e-7, 1.22e-6], \"m\" : [0.5981, 0.5816] }) set_perm_vapor() There are currently two methods for defining the water vapor permeability: Either by interpolation between measurement points: concrete.set_perm_vapor('interp', **{\"HR\" : [0.25, 0.75], \"dp\" : [4.2e-12, 7.8e-12] } ) Ot with the Schirmer law: lightweight.set_perm_vapor('schirmer', **{\"mu\" : 5.6, \"p\" : 0.2 }) set_perm_liquid() There are currently two methods for defining the liquid permeability: Either with an exponential law: lightweight.set_perm_liquid('exp', **{\"a\" : [-46.245, 294.506, -1439, 3249, -3370, 1305] } ) Or with the Durner multi-modal law: concrete.set_perm_liquid('durner', **{\"K_sat\" : 2.2182e-13, \"tau\" : -4.6974, \"l\" : [0.5062, 0.4938], \"alpha\" : [5.5383e-7, 2.2493e-8], \"m\" : [0.6148, 0.1913] } ) Note that if this method is not used in the definition of a material, this permeability will be set to 0 and liquid transfer will not be considered in the calculation. set_perm_air() The air permeability should be given in (m^2^). Only a constant value is expected: lightweight.set_perm_air(1.08e-10) Calling this method is optional: the default air permeability is 0 . Calling properties Once defined, all properties may be called as fonctions of the temperature T and capillary pressure p_c . The following methods are bound within the Material class for this purpose material.rho(T) : density material.cp(T) : heat capacity material.conduc(p_c, T) : heat conductivity ( p_c and T are optional arguments) material.w(p_c) : moisture content (kg/m3) material.c_v(p_c) : moisture capacity (derivative of the moisture content) material.delta_p(p_c, T) : vapour permeability ( T is an optional argument) material.k_l(p_c, T) : liquid permeability ( T is an optional argument) material.k_air() : air permeability Important : hamopy is written with the capillary pressure as the driving potential for moisture transfer. All variables depending on the humidity are therefore methods expecting p_c as input argument, rather than the value of relative humidity or vapor pressure. Some functions are however available in the library to easily switch from one another. Switch materials Once a material has been integrated into a Mesh object, it is still possible to change some of its properties and tell the mesh of the modifications: from hamopy.materials.standard import concrete, wood_fibre from copy import deepcopy mesh = Mesh(**{\"materials\" : [concrete, wood_fibre], \"sizes\" : [0.1, 0.08], \"nbr_elements\" : [16, 12] }) wood_fibre_2 = deepcopy(wood_fibre) wood_fibre_2.set_density(170.) mesh.replace_materials([concrete, wood_fibre_2]) This functionality is particularly interesting when running a large number of simulations with different material properties, like in case of a sensitivity analysis. The instantiation of the Mesh and Material objects is not repeated, which saves some time. Documentation main page","title":"Materials"},{"location":"user-guide/materials/#creating-materials","text":"As shown on the input definition page, creating the mesh object for the simulation requires including a material object in the arguments of the Mesh instantiation. from hamopy.classes import Mesh from hamopy.materials.standard import wood_fibre mesh = Mesh(materials = [wood_fibre], sizes = [0.08], nbr_elem = [16] ) This means that the hamopy\\materials\\standard.py file contains the definition of an object called wood_fibre , which is of the Material class and includes all material data. Material definition in hamopy is a bit tricky, as it was designed to give the user maximum freedom for defining fully customisable transport properties. This page tells you how to define a new material, use its properties once they have been registered, modify a material in an existing mesh.","title":"Creating materials"},{"location":"user-guide/materials/#material-definition","text":"","title":"Material definition"},{"location":"user-guide/materials/#instantiation","text":"For purposes of reusability, the definition of a new material should preferably be done in a separate file which you can then import into your script (like hamopy.materials.standard above) Once there, you may start by instantiating a new Material object: from hamopy.classes import Material concrete = Material('concrete', rho = 2400., cp = 880.) The instantiation may take up to three arguments: the material name, its dry density (kg/m3) and specific heat (J/(kg.K)). Once created, the Material object contains the following set of methods to register all material properties.","title":"Instantiation"},{"location":"user-guide/materials/#set_density","text":"If not provided at the instantiation, you can specify the dry density of the material like so: concrete.set_density(2430.)","title":"set_density()"},{"location":"user-guide/materials/#set_capacity","text":"In the current state of hamopy, the heat capacity (J/(kg.K)) of the dry material can be defined as a function of the temperature. concrete.set_capacity(cp_0 = 2430., cp_t = 27.) When called, the value of the heat capacity will then be cp = cp_0 + T(\u00b0C) * cp_t The default value for cp_t is 0.","title":"set_capacity()"},{"location":"user-guide/materials/#set_conduc","text":"The thermal conductivity (W/(m.K)) may be defined as a function of the moisture content and temperature. concrete.set_conduc(lambda_0 = 1.75, lambda_m = 4.5, lambda_t = 1e-4) When called, the value of the conductivity will then be lambda = lambda_0 + w(kg/m3)/1000 * lambda_m + T(\u00b0C) * lambda_t The default value for lambda_m and lambda_t is 0.","title":"set_conduc()"},{"location":"user-guide/materials/#set_isotherm","text":"There are currently two methods for defining the sorption isotherm: Either a 3rd degree polynomial interpolation, fitted on a list of measurement points: wood_fibre.set_isotherm('polynomial', **{\"HR\" : [0, 0.25, 0.5, 0.75], \"W\" : [0, 6.2, 12.4, 20.9] }) where the list given in the 'W' key are the values of the moisture content measured at the relative humidities 'HR' . The second method for defining the sorption isotherm is the van Genuchten mono- or multimodal law: lightweight.set_isotherm('vangenuchten', **{\"w_sat\" : 871, \"l\" : [0.41, 0.59], \"alpha\" : [6.12e-7, 1.22e-6], \"m\" : [0.5981, 0.5816] })","title":"set_isotherm()"},{"location":"user-guide/materials/#set_perm_vapor","text":"There are currently two methods for defining the water vapor permeability: Either by interpolation between measurement points: concrete.set_perm_vapor('interp', **{\"HR\" : [0.25, 0.75], \"dp\" : [4.2e-12, 7.8e-12] } ) Ot with the Schirmer law: lightweight.set_perm_vapor('schirmer', **{\"mu\" : 5.6, \"p\" : 0.2 })","title":"set_perm_vapor()"},{"location":"user-guide/materials/#set_perm_liquid","text":"There are currently two methods for defining the liquid permeability: Either with an exponential law: lightweight.set_perm_liquid('exp', **{\"a\" : [-46.245, 294.506, -1439, 3249, -3370, 1305] } ) Or with the Durner multi-modal law: concrete.set_perm_liquid('durner', **{\"K_sat\" : 2.2182e-13, \"tau\" : -4.6974, \"l\" : [0.5062, 0.4938], \"alpha\" : [5.5383e-7, 2.2493e-8], \"m\" : [0.6148, 0.1913] } ) Note that if this method is not used in the definition of a material, this permeability will be set to 0 and liquid transfer will not be considered in the calculation.","title":"set_perm_liquid()"},{"location":"user-guide/materials/#set_perm_air","text":"The air permeability should be given in (m^2^). Only a constant value is expected: lightweight.set_perm_air(1.08e-10) Calling this method is optional: the default air permeability is 0 .","title":"set_perm_air()"},{"location":"user-guide/materials/#calling-properties","text":"Once defined, all properties may be called as fonctions of the temperature T and capillary pressure p_c . The following methods are bound within the Material class for this purpose material.rho(T) : density material.cp(T) : heat capacity material.conduc(p_c, T) : heat conductivity ( p_c and T are optional arguments) material.w(p_c) : moisture content (kg/m3) material.c_v(p_c) : moisture capacity (derivative of the moisture content) material.delta_p(p_c, T) : vapour permeability ( T is an optional argument) material.k_l(p_c, T) : liquid permeability ( T is an optional argument) material.k_air() : air permeability Important : hamopy is written with the capillary pressure as the driving potential for moisture transfer. All variables depending on the humidity are therefore methods expecting p_c as input argument, rather than the value of relative humidity or vapor pressure. Some functions are however available in the library to easily switch from one another.","title":"Calling properties"},{"location":"user-guide/materials/#switch-materials","text":"Once a material has been integrated into a Mesh object, it is still possible to change some of its properties and tell the mesh of the modifications: from hamopy.materials.standard import concrete, wood_fibre from copy import deepcopy mesh = Mesh(**{\"materials\" : [concrete, wood_fibre], \"sizes\" : [0.1, 0.08], \"nbr_elements\" : [16, 12] }) wood_fibre_2 = deepcopy(wood_fibre) wood_fibre_2.set_density(170.) mesh.replace_materials([concrete, wood_fibre_2]) This functionality is particularly interesting when running a large number of simulations with different material properties, like in case of a sensitivity analysis. The instantiation of the Mesh and Material objects is not repeated, which saves some time. Documentation main page","title":"Switch materials"},{"location":"user-guide/post-processing/","text":"Post-processing Let's say you have correctly defined all simulation inputs and successfully performed a simulation run . The last part of your script may look like this: from hamopy.algorithm import calcul results = calcul(mesh, clim, init, time) Now you want to display and analyse some results, which is why you use this program in the first place. Simulation outcome By default, the main algorithm of hamopy returns a dictionary containing all simulation results and everything one needs to interpret them. Here is a list of all keys and values stored within this dictionary. 'x' : Mesh node coordinates; size: (N,) 't' : All time coordinates of the simulation; size: (M,) 'T' : Temperature; size: (M,N) 'PC' : Capillary pressure; size: (M,N) 'HR' : Relative humidity; size: (M,N) 'PV' : Vapor pressure; size: (M,N) All values are numpy arrays. This is for instance how to read the temperature of the i^th node at the j^th time of simulation: results['T'][j,i] As this data is a bit raw, two methods are available to easily extract data at user-defined times and locations without having to directly manipulate elements of the results dictionary. evolution() The evolution() method of the hamopy.postpro module helps extract the temporal evolution of a variable at a specific location. from hamopy.postpro import evolution import numpy as np x_out = 0.05 t_out = np.array([0, 60, 120, 180, 240, 300, 360]) T_out = evolution(results, 'T', x_out, t_out) This example returns the evolution of the temperature over time, at the point given by x_out , with the temporal discretisation given by t_out . The function may take 4 input arguments: the dictionary of results, provided by the simulation a string denoting which variable to extract (it must be one of the keys of results ) the location of the point (preferably a single value) the time scale on which to extract the data (numpy array) The last argument is optional: if not given, evolution() will take all time coordinates in results['t'] (this is not advised if the simulation time step size was adaptative). distribution() The distribution() method of the hamopy.postpro module helps extract the spatial distribution of a variable at a specific time. from hamopy.postpro import distribution import numpy as np x_out = np.array([0, 0.02, 0.04, 0.06, 0.08, 0.10]) t_out = 3600 HR_out = distribution(results, 'HR', x_out, t_out) This example returns the distribution of relative humidity, at the time given by t_out , over the spatial discretisation given by x_out . The function may take 4 input arguments: the dictionary of results, provided by the simulation a string denoting which variable to extract (it must be one of the keys of results ) the coordinates on which the distribution spans (numpy array) the time of the distribution (preferably a single value) The third argument is optional: if not given, distribution() will take all mesh node coordinates in results['x'] . Documentation main page","title":"Post-processing"},{"location":"user-guide/post-processing/#post-processing","text":"Let's say you have correctly defined all simulation inputs and successfully performed a simulation run . The last part of your script may look like this: from hamopy.algorithm import calcul results = calcul(mesh, clim, init, time) Now you want to display and analyse some results, which is why you use this program in the first place.","title":"Post-processing"},{"location":"user-guide/post-processing/#simulation-outcome","text":"By default, the main algorithm of hamopy returns a dictionary containing all simulation results and everything one needs to interpret them. Here is a list of all keys and values stored within this dictionary. 'x' : Mesh node coordinates; size: (N,) 't' : All time coordinates of the simulation; size: (M,) 'T' : Temperature; size: (M,N) 'PC' : Capillary pressure; size: (M,N) 'HR' : Relative humidity; size: (M,N) 'PV' : Vapor pressure; size: (M,N) All values are numpy arrays. This is for instance how to read the temperature of the i^th node at the j^th time of simulation: results['T'][j,i] As this data is a bit raw, two methods are available to easily extract data at user-defined times and locations without having to directly manipulate elements of the results dictionary.","title":"Simulation outcome"},{"location":"user-guide/post-processing/#evolution","text":"The evolution() method of the hamopy.postpro module helps extract the temporal evolution of a variable at a specific location. from hamopy.postpro import evolution import numpy as np x_out = 0.05 t_out = np.array([0, 60, 120, 180, 240, 300, 360]) T_out = evolution(results, 'T', x_out, t_out) This example returns the evolution of the temperature over time, at the point given by x_out , with the temporal discretisation given by t_out . The function may take 4 input arguments: the dictionary of results, provided by the simulation a string denoting which variable to extract (it must be one of the keys of results ) the location of the point (preferably a single value) the time scale on which to extract the data (numpy array) The last argument is optional: if not given, evolution() will take all time coordinates in results['t'] (this is not advised if the simulation time step size was adaptative).","title":"evolution()"},{"location":"user-guide/post-processing/#distribution","text":"The distribution() method of the hamopy.postpro module helps extract the spatial distribution of a variable at a specific time. from hamopy.postpro import distribution import numpy as np x_out = np.array([0, 0.02, 0.04, 0.06, 0.08, 0.10]) t_out = 3600 HR_out = distribution(results, 'HR', x_out, t_out) This example returns the distribution of relative humidity, at the time given by t_out , over the spatial discretisation given by x_out . The function may take 4 input arguments: the dictionary of results, provided by the simulation a string denoting which variable to extract (it must be one of the keys of results ) the coordinates on which the distribution spans (numpy array) the time of the distribution (preferably a single value) The third argument is optional: if not given, distribution() will take all mesh node coordinates in results['x'] . Documentation main page","title":"distribution()"},{"location":"user-guide/simulation/","text":"Running a simulation Let's say you have correctly defined all conditions of the simulation by reading this helpful page . All you need to do now is import the main algorithm and run it from hamopy.algorithm import calcul results = calcul(mesh, clim, init, time) The rest is post-processing . Options The syntax for calling the simulation may be slightly modified for three purposes: choosing the type of output, keeping a record of the simulation process, or simulate thermal transfer only. Output type The calcul() method normally returns a dictionary storing all necessary data for post-processing . Another available option is to save this data into a file in the uncompressed .npz format from hamopy.algorithm import calcul calcul(mesh, clim, init, time, output_type = 'file') This will create a file called hamopy_output.npz in the working directory. This method of output selection can be customised by modifying the algorithm module. Diary Should you encounter convergence difficulties, you may want the algorithm to store its progress somewhere so you may locate the problems. The calcul() method may take an additional argument for this purpose: from hamopy.algorithm import calcul diary = 'file_name' results = calcul(mesh, clim, init, time, logfile = diary) This will create a file at the specified location, on which the record of the convergence criteria will be saved. Heat transfer only The code is initially designed for coupled heat and moisture transfer, but the user may want to skip the humidity and only calculate heat. This is done through an alternate version of the algorithm: from hamopy.algorithm import calcul_thermo results = calcul_thermo(mesh, clim, init, time) This should run about 4 times faster than coupled heat and mass transfer. Documentation main page","title":"Simulation"},{"location":"user-guide/simulation/#running-a-simulation","text":"Let's say you have correctly defined all conditions of the simulation by reading this helpful page . All you need to do now is import the main algorithm and run it from hamopy.algorithm import calcul results = calcul(mesh, clim, init, time) The rest is post-processing .","title":"Running a simulation"},{"location":"user-guide/simulation/#options","text":"The syntax for calling the simulation may be slightly modified for three purposes: choosing the type of output, keeping a record of the simulation process, or simulate thermal transfer only.","title":"Options"},{"location":"user-guide/simulation/#output-type","text":"The calcul() method normally returns a dictionary storing all necessary data for post-processing . Another available option is to save this data into a file in the uncompressed .npz format from hamopy.algorithm import calcul calcul(mesh, clim, init, time, output_type = 'file') This will create a file called hamopy_output.npz in the working directory. This method of output selection can be customised by modifying the algorithm module.","title":"Output type"},{"location":"user-guide/simulation/#diary","text":"Should you encounter convergence difficulties, you may want the algorithm to store its progress somewhere so you may locate the problems. The calcul() method may take an additional argument for this purpose: from hamopy.algorithm import calcul diary = 'file_name' results = calcul(mesh, clim, init, time, logfile = diary) This will create a file at the specified location, on which the record of the convergence criteria will be saved.","title":"Diary"},{"location":"user-guide/simulation/#heat-transfer-only","text":"The code is initially designed for coupled heat and moisture transfer, but the user may want to skip the humidity and only calculate heat. This is done through an alternate version of the algorithm: from hamopy.algorithm import calcul_thermo results = calcul_thermo(mesh, clim, init, time) This should run about 4 times faster than coupled heat and mass transfer. Documentation main page","title":"Heat transfer only"}]}